
// protocol Movable {
//    func move(by: Int)
//    var hasMoved:Bool  {get}
//    var distanceFromStart:Int  {get set}
// }
//
// struct PortableThing: Movable{
//
//    func move(by: Int) {
//
//    }
//
//    var hasMoved: Bool
//
//    var distanceFromStart: Int
// }

// struct Array<Element> where Element:Equatable
// some vs any

// function as types
// (Int,Int) -> Bool
// (Double) -> Void
// () -> List<String>
// () -> Void

// var foo:(Double) -> Void
// var doSomething(what ()->Bool)

// var operation: (Double) -> Double
// func square(operand:Double) -> Double
//    return operand*operand
//
// operation = square
// let result = operation(4)




//    function as type
//    private var model = MemoryGame(numberOfPairsOfCards: 4, cardContentFactory: createCardContent)
// clousre
//    private var model = MemoryGame(numberOfPairsOfCards: 4, cardContentFactory: {(index:Int) -> String in
//        return ["ğŸƒ", "ğŸ‘»", "ğŸ•¸ï¸", "ğŸ§›â€â™‚ï¸", "ğŸ§™â€â™€ï¸", "ğŸ˜œ", "ğŸ¤¡", "ğŸ˜‚", "ğŸ‘½", "ğŸ’€", "ğŸ˜ˆ", "ğŸ¤–", "ğŸ‘º", "ğŸ‘¹", "ğŸ¬"][index]
//    }
//    )
//    clousure syntax wit type inferring
//    private var model = MemoryGame(numberOfPairsOfCards: 4, cardContentFactory: { index in
//        return ["ğŸƒ", "ğŸ‘»", "ğŸ•¸ï¸", "ğŸ§›â€â™‚ï¸", "ğŸ§™â€â™€ï¸", "ğŸ˜œ", "ğŸ¤¡", "ğŸ˜‚", "ğŸ‘½", "ğŸ’€", "ğŸ˜ˆ", "ğŸ¤–", "ğŸ‘º", "ğŸ‘¹", "ğŸ¬"][index]
//    }
//    )
// trailing clousre syntax , you can use $0,1,2 etc as well but its not readable
//    private var model = MemoryGame(numberOfPairsOfCards: 4) { pairIndex in
//        return emojis[pairIndex]
//    }


// func createCardContent(forPairAtIndex index:Int) -> String {
//    return ["ğŸƒ", "ğŸ‘»", "ğŸ•¸ï¸", "ğŸ§›â€â™‚ï¸", "ğŸ§™â€â™€ï¸", "ğŸ˜œ", "ğŸ¤¡", "ğŸ˜‚", "ğŸ‘½", "ğŸ’€", "ğŸ˜ˆ", "ğŸ¤–", "ğŸ‘º", "ğŸ‘¹", "ğŸ¬"][index]
// }
